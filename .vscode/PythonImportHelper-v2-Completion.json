[
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "glob",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "glob",
        "description": "glob",
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "sysconfig",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sysconfig",
        "description": "sysconfig",
        "detail": "sysconfig",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "winreg",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "winreg",
        "description": "winreg",
        "detail": "winreg",
        "documentation": {}
    },
    {
        "label": "site",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "site",
        "description": "site",
        "detail": "site",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "io",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "io",
        "description": "io",
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "asset",
        "importPath": "dagster",
        "description": "dagster",
        "isExtraImport": true,
        "detail": "dagster",
        "documentation": {}
    },
    {
        "label": "asset_check",
        "importPath": "dagster",
        "description": "dagster",
        "isExtraImport": true,
        "detail": "dagster",
        "documentation": {}
    },
    {
        "label": "AssetCheckResult",
        "importPath": "dagster",
        "description": "dagster",
        "isExtraImport": true,
        "detail": "dagster",
        "documentation": {}
    },
    {
        "label": "Definitions",
        "importPath": "dagster",
        "description": "dagster",
        "isExtraImport": true,
        "detail": "dagster",
        "documentation": {}
    },
    {
        "label": "load_assets_from_modules",
        "importPath": "dagster",
        "description": "dagster",
        "isExtraImport": true,
        "detail": "dagster",
        "documentation": {}
    },
    {
        "label": "assets",
        "importPath": "final_project",
        "description": "final_project",
        "isExtraImport": true,
        "detail": "final_project",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "unicodedata",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unicodedata",
        "description": "unicodedata",
        "detail": "unicodedata",
        "documentation": {}
    },
    {
        "label": "pprint",
        "importPath": "pprint",
        "description": "pprint",
        "isExtraImport": true,
        "detail": "pprint",
        "documentation": {}
    },
    {
        "label": "modulo_cadenas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "modulo_cadenas",
        "description": "modulo_cadenas",
        "detail": "modulo_cadenas",
        "documentation": {}
    },
    {
        "label": "normalize",
        "importPath": "textkit",
        "description": "textkit",
        "isExtraImport": true,
        "detail": "textkit",
        "documentation": {}
    },
    {
        "label": "slugify",
        "importPath": "textkit",
        "description": "textkit",
        "isExtraImport": true,
        "detail": "textkit",
        "documentation": {}
    },
    {
        "label": "is_slug",
        "importPath": "textkit",
        "description": "textkit",
        "isExtraImport": true,
        "detail": "textkit",
        "documentation": {}
    },
    {
        "label": "require_non_empty",
        "importPath": "textkit",
        "description": "textkit",
        "isExtraImport": true,
        "detail": "textkit",
        "documentation": {}
    },
    {
        "label": "textkit.validators",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "textkit.validators",
        "description": "textkit.validators",
        "detail": "textkit.validators",
        "documentation": {}
    },
    {
        "label": "suma",
        "importPath": "operaciones",
        "description": "operaciones",
        "isExtraImport": true,
        "detail": "operaciones",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "operaciones",
        "description": "operaciones",
        "isExtraImport": true,
        "detail": "operaciones",
        "documentation": {}
    },
    {
        "label": "suma",
        "importPath": "labs.lab3.src.operaciones",
        "description": "labs.lab3.src.operaciones",
        "isExtraImport": true,
        "detail": "labs.lab3.src.operaciones",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "labs.lab3.src.operaciones",
        "description": "labs.lab3.src.operaciones",
        "isExtraImport": true,
        "detail": "labs.lab3.src.operaciones",
        "documentation": {}
    },
    {
        "label": "pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest",
        "description": "pytest",
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "duckdb",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "duckdb",
        "description": "duckdb",
        "detail": "duckdb",
        "documentation": {}
    },
    {
        "label": "csv",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "csv",
        "description": "csv",
        "detail": "csv",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "normalize_spaces",
        "importPath": "textutils",
        "description": "textutils",
        "isExtraImport": true,
        "detail": "textutils",
        "documentation": {}
    },
    {
        "label": "word_count",
        "importPath": "textutils",
        "description": "textutils",
        "isExtraImport": true,
        "detail": "textutils",
        "documentation": {}
    },
    {
        "label": "is_palindrome",
        "importPath": "textutils",
        "description": "textutils",
        "isExtraImport": true,
        "detail": "textutils",
        "documentation": {}
    },
    {
        "label": "normalize_spaces",
        "importPath": "textutils",
        "description": "textutils",
        "isExtraImport": true,
        "detail": "textutils",
        "documentation": {}
    },
    {
        "label": "word_count",
        "importPath": "textutils",
        "description": "textutils",
        "isExtraImport": true,
        "detail": "textutils",
        "documentation": {}
    },
    {
        "label": "is_palindrome",
        "importPath": "textutils",
        "description": "textutils",
        "isExtraImport": true,
        "detail": "textutils",
        "documentation": {}
    },
    {
        "label": "validate_csv",
        "importPath": "csv_validation",
        "description": "csv_validation",
        "isExtraImport": true,
        "detail": "csv_validation",
        "documentation": {}
    },
    {
        "label": "validate_csv",
        "importPath": "csv_validation",
        "description": "csv_validation",
        "isExtraImport": true,
        "detail": "csv_validation",
        "documentation": {}
    },
    {
        "label": "sys,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys.",
        "description": "sys.",
        "detail": "sys.",
        "documentation": {}
    },
    {
        "label": "Tee",
        "kind": 6,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "class Tee:\n    def __init__(self, file):\n        self.f = file\n    def write(self, what):\n        if self.f is not None:\n            try:\n                self.f.write(what.replace(\"\\n\", \"\\r\\n\"))\n            except OSError:\n                pass\n        tee_f.write(what)",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_root_hkey",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_root_hkey():\n    try:\n        winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE, root_key_name, 0, winreg.KEY_CREATE_SUB_KEY\n        )\n        return winreg.HKEY_LOCAL_MACHINE\n    except OSError:\n        # Either not exist, or no permissions to create subkey means\n        # must be HKCU\n        return winreg.HKEY_CURRENT_USER",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "create_shortcut",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def create_shortcut(\n    path, description, filename, arguments=\"\", workdir=\"\", iconpath=\"\", iconindex=0\n):\n    import pythoncom\n    from win32com.shell import shell\n    ilink = pythoncom.CoCreateInstance(\n        shell.CLSID_ShellLink,\n        None,\n        pythoncom.CLSCTX_INPROC_SERVER,\n        shell.IID_IShellLink,",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_special_folder_path",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_special_folder_path(path_name):\n    from win32com.shell import shell, shellcon\n    for maybe in \"\"\"\n        CSIDL_COMMON_STARTMENU CSIDL_STARTMENU CSIDL_COMMON_APPDATA\n        CSIDL_LOCAL_APPDATA CSIDL_APPDATA CSIDL_COMMON_DESKTOPDIRECTORY\n        CSIDL_DESKTOPDIRECTORY CSIDL_COMMON_STARTUP CSIDL_STARTUP\n        CSIDL_COMMON_PROGRAMS CSIDL_PROGRAMS CSIDL_PROGRAM_FILES_COMMON\n        CSIDL_PROGRAM_FILES CSIDL_FONTS\"\"\".split():\n        if maybe == path_name:\n            csidl = getattr(shellcon, maybe)",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "CopyTo",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def CopyTo(desc, src, dest):\n    import win32api\n    import win32con\n    while 1:\n        try:\n            win32api.CopyFile(src, dest, 0)\n            return\n        except win32api.error as details:\n            if details.winerror == 5:  # access denied - user not admin.\n                raise",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "LoadSystemModule",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def LoadSystemModule(lib_dir, modname):\n    # See if this is a debug build.\n    import importlib.machinery\n    import importlib.util\n    suffix = \"_d\" if \"_d.pyd\" in importlib.machinery.EXTENSION_SUFFIXES else \"\"\n    filename = \"%s%d%d%s.dll\" % (\n        modname,\n        sys.version_info.major,\n        sys.version_info.minor,\n        suffix,",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "SetPyKeyVal",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def SetPyKeyVal(key_name, value_name, value):\n    root_hkey = get_root_hkey()\n    root_key = winreg.OpenKey(root_hkey, root_key_name)\n    try:\n        my_key = winreg.CreateKey(root_key, key_name)\n        try:\n            winreg.SetValueEx(my_key, value_name, 0, winreg.REG_SZ, value)\n            if verbose:\n                print(f\"-> {root_key_name}\\\\{key_name}[{value_name}]={value!r}\")\n        finally:",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "UnsetPyKeyVal",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def UnsetPyKeyVal(key_name, value_name, delete_key=False):\n    root_hkey = get_root_hkey()\n    root_key = winreg.OpenKey(root_hkey, root_key_name)\n    try:\n        my_key = winreg.OpenKey(root_key, key_name, 0, winreg.KEY_SET_VALUE)\n        try:\n            winreg.DeleteValue(my_key, value_name)\n            if verbose:\n                print(f\"-> DELETE {root_key_name}\\\\{key_name}[{value_name}]\")\n        finally:",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "RegisterCOMObjects",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def RegisterCOMObjects(register=True):\n    import win32com.server.register\n    if register:\n        func = win32com.server.register.RegisterClasses\n    else:\n        func = win32com.server.register.UnregisterClasses\n    flags = {}\n    if not verbose:\n        flags[\"quiet\"] = 1\n    for module, klass_name in com_modules:",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "RegisterHelpFile",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def RegisterHelpFile(register=True, lib_dir=None):\n    if lib_dir is None:\n        lib_dir = sysconfig.get_paths()[\"platlib\"]\n    if register:\n        # Register the .chm help file.\n        chm_file = os.path.join(lib_dir, \"PyWin32.chm\")\n        if os.path.isfile(chm_file):\n            # This isn't recursive, so if 'Help' doesn't exist, we croak\n            SetPyKeyVal(\"Help\", None, None)\n            SetPyKeyVal(\"Help\\\\Pythonwin Reference\", None, chm_file)",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "RegisterPythonwin",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def RegisterPythonwin(register=True, lib_dir=None):\n    \"\"\"Add (or remove) Pythonwin to context menu for python scripts.\n    ??? Should probably also add Edit command for pys files also.\n    Also need to remove these keys on uninstall, but there's no function\n    to add registry entries to uninstall log ???\n    \"\"\"\n    import os\n    if lib_dir is None:\n        lib_dir = sysconfig.get_paths()[\"platlib\"]\n    classes_root = get_root_hkey()",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_shortcuts_folder",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_shortcuts_folder():\n    if get_root_hkey() == winreg.HKEY_LOCAL_MACHINE:\n        try:\n            fldr = get_special_folder_path(\"CSIDL_COMMON_PROGRAMS\")\n        except OSError:\n            # No CSIDL_COMMON_PROGRAMS on this platform\n            fldr = get_special_folder_path(\"CSIDL_PROGRAMS\")\n    else:\n        # non-admin install - always goes in this user's start menu.\n        fldr = get_special_folder_path(\"CSIDL_PROGRAMS\")",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_system_dir",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_system_dir():\n    import win32api  # we assume this exists.\n    try:\n        import pythoncom\n        import win32process\n        from win32com.shell import shell, shellcon\n        try:\n            if win32process.IsWow64Process():\n                return shell.SHGetSpecialFolderPath(0, shellcon.CSIDL_SYSTEMX86)\n            return shell.SHGetSpecialFolderPath(0, shellcon.CSIDL_SYSTEM)",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "fixup_dbi",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def fixup_dbi():\n    # We used to have a dbi.pyd with our .pyd files, but now have a .py file.\n    # If the user didn't uninstall, they will find the .pyd which will cause\n    # problems - so handle that.\n    import win32api\n    import win32con\n    pyd_name = os.path.join(os.path.dirname(win32api.__file__), \"dbi.pyd\")\n    pyd_d_name = os.path.join(os.path.dirname(win32api.__file__), \"dbi_d.pyd\")\n    py_name = os.path.join(os.path.dirname(win32con.__file__), \"dbi.py\")\n    for this_pyd in (pyd_name, pyd_d_name):",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "install",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def install(lib_dir):\n    import traceback\n    # The .pth file is now installed as a regular file.\n    # Create the .pth file in the site-packages dir, and use only relative paths\n    # We used to write a .pth directly to sys.prefix - clobber it.\n    if os.path.isfile(os.path.join(sys.prefix, \"pywin32.pth\")):\n        os.unlink(os.path.join(sys.prefix, \"pywin32.pth\"))\n    # The .pth may be new and therefore not loaded in this session.\n    # Setup the paths just in case.\n    for name in \"win32 win32\\\\lib Pythonwin\".split():",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "uninstall",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def uninstall(lib_dir):\n    # First ensure our system modules are loaded from pywin32_system, so\n    # we can remove the ones we copied...\n    LoadSystemModule(lib_dir, \"pywintypes\")\n    LoadSystemModule(lib_dir, \"pythoncom\")\n    try:\n        RegisterCOMObjects(False)\n    except Exception as why:\n        print(f\"Failed to unregister COM objects: {why}\")\n    try:",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "verify_destination",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def verify_destination(location: str) -> str:\n    location = os.path.abspath(location)\n    if not os.path.isdir(location):\n        raise argparse.ArgumentTypeError(\n            f'Path \"{location}\" is not an existing directory!'\n        )\n    return location\ndef main():\n    parser = argparse.ArgumentParser(\n        formatter_class=argparse.RawDescriptionHelpFormatter,",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser(\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        description=\"\"\"A post-install script for the pywin32 extensions.\n    * Typical usage:\n    > python -m pywin32_postinstall -install\n    * or (shorter but you don't have control over which python environment is used)\n    > pywin32_postinstall -install\n    You need to execute this script, with a '-install' parameter,\n    to ensure the environment is setup correctly to install COM objects, services, etc.",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "tee_f",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "tee_f = open(\n    os.path.join(\n        tempfile.gettempdir(),  # Send output somewhere so it can be found if necessary...\n        \"pywin32_postinstall.log\",\n    ),\n    \"w\",\n)\nclass Tee:\n    def __init__(self, file):\n        self.f = file",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "sys.stderr",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "sys.stderr = Tee(sys.stderr)\nsys.stdout = Tee(sys.stdout)\ncom_modules = [\n    # module_name,                      class_names\n    (\"win32com.servers.interp\", \"Interpreter\"),\n    (\"win32com.servers.dictionary\", \"DictionaryPolicy\"),\n    (\"win32com.axscript.client.pyscript\", \"PyScript\"),\n]\n# Is this a 'silent' install - ie, avoid all dialogs.\n# Different than 'verbose'",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "sys.stdout",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "sys.stdout = Tee(sys.stdout)\ncom_modules = [\n    # module_name,                      class_names\n    (\"win32com.servers.interp\", \"Interpreter\"),\n    (\"win32com.servers.dictionary\", \"DictionaryPolicy\"),\n    (\"win32com.axscript.client.pyscript\", \"PyScript\"),\n]\n# Is this a 'silent' install - ie, avoid all dialogs.\n# Different than 'verbose'\nsilent = 0",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "com_modules",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "com_modules = [\n    # module_name,                      class_names\n    (\"win32com.servers.interp\", \"Interpreter\"),\n    (\"win32com.servers.dictionary\", \"DictionaryPolicy\"),\n    (\"win32com.axscript.client.pyscript\", \"PyScript\"),\n]\n# Is this a 'silent' install - ie, avoid all dialogs.\n# Different than 'verbose'\nsilent = 0\n# Verbosity of output messages.",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "silent",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "silent = 0\n# Verbosity of output messages.\nverbose = 1\nroot_key_name = \"Software\\\\Python\\\\PythonCore\\\\\" + sys.winver\ndef get_root_hkey():\n    try:\n        winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE, root_key_name, 0, winreg.KEY_CREATE_SUB_KEY\n        )\n        return winreg.HKEY_LOCAL_MACHINE",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "verbose",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "verbose = 1\nroot_key_name = \"Software\\\\Python\\\\PythonCore\\\\\" + sys.winver\ndef get_root_hkey():\n    try:\n        winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE, root_key_name, 0, winreg.KEY_CREATE_SUB_KEY\n        )\n        return winreg.HKEY_LOCAL_MACHINE\n    except OSError:\n        # Either not exist, or no permissions to create subkey means",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "root_key_name",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "root_key_name = \"Software\\\\Python\\\\PythonCore\\\\\" + sys.winver\ndef get_root_hkey():\n    try:\n        winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE, root_key_name, 0, winreg.KEY_CREATE_SUB_KEY\n        )\n        return winreg.HKEY_LOCAL_MACHINE\n    except OSError:\n        # Either not exist, or no permissions to create subkey means\n        # must be HKCU",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "run_test",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "def run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras\n    print(\"--- Running '%s' ---\" % script)\n    sys.stdout.flush()\n    result = subprocess.run(cmd, check=False, cwd=dirname)\n    print(f\"*** Test script '{script}' exited with {result.returncode}\")\n    sys.stdout.flush()\n    if result.returncode:",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "find_and_run",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "def find_and_run(possible_locations, extras):\n    for maybe in possible_locations:\n        if os.path.isfile(maybe):\n            run_test(maybe, extras)\n            break\n    else:\n        raise RuntimeError(\n            \"Failed to locate a test script in one of %s\" % possible_locations\n        )\ndef main():",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "def main():\n    import argparse\n    code_directories = [project_root] + site_packages\n    parser = argparse.ArgumentParser(\n        description=\"A script to trigger tests in all subprojects of PyWin32.\"\n    )\n    parser.add_argument(\n        \"-no-user-interaction\",\n        default=False,\n        action=\"store_true\",",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "project_root",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "project_root = os.path.dirname(os.path.dirname(os.path.dirname(__file__)))\nsite_packages = [site.getusersitepackages()] + site.getsitepackages()\nfailures = []\n# Run a test using subprocess and wait for the result.\n# If we get an returncode != 0, we know that there was an error, but we don't\n# abort immediately - we run as many tests as we can.\ndef run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "site_packages",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "site_packages = [site.getusersitepackages()] + site.getsitepackages()\nfailures = []\n# Run a test using subprocess and wait for the result.\n# If we get an returncode != 0, we know that there was an error, but we don't\n# abort immediately - we run as many tests as we can.\ndef run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras\n    print(\"--- Running '%s' ---\" % script)",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "failures",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "failures = []\n# Run a test using subprocess and wait for the result.\n# If we get an returncode != 0, we know that there was an error, but we don't\n# abort immediately - we run as many tests as we can.\ndef run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras\n    print(\"--- Running '%s' ---\" % script)\n    sys.stdout.flush()",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "procesar_base",
        "kind": 2,
        "importPath": "final_project.src.final_project.assets",
        "description": "final_project.src.final_project.assets",
        "peekOfCode": "def procesar_base(df: pd.DataFrame, pais_a: str, pais_b: str) -> pd.DataFrame:\n    df = df.copy()\n    # Normaliza fecha a tz-naive\n    df[\"date\"] = pd.to_datetime(df[\"date\"], errors=\"coerce\", utc=True).dt.tz_convert(None)\n    # Coerción numérica\n    for col in [\"new_cases\", \"people_vaccinated\", \"population\"]:\n        if col in df.columns:\n            df[col] = pd.to_numeric(df[col], errors=\"coerce\")\n    # nulos críticos y duplicados clave\n    loc = _loc_col(df)",
        "detail": "final_project.src.final_project.assets",
        "documentation": {}
    },
    {
        "label": "compute_incidencia_7d",
        "kind": 2,
        "importPath": "final_project.src.final_project.assets",
        "description": "final_project.src.final_project.assets",
        "peekOfCode": "def compute_incidencia_7d(df: pd.DataFrame) -> pd.DataFrame:\n    df = df.copy().sort_values([\"location\", \"date\"])\n    df[\"incidencia_diaria\"] = (df[\"new_cases\"] / df[\"population\"]) * 100000\n    df[\"incidencia_7d\"] = (\n        df.groupby(\"location\")[\"incidencia_diaria\"].transform(lambda s: s.rolling(7, min_periods=1).mean())\n    )\n    return df[[\"date\", \"location\", \"incidencia_7d\"]].rename(columns={\"date\": \"fecha\", \"location\": \"pais\"})\ndef compute_factor_crec_7d(df: pd.DataFrame) -> pd.DataFrame:\n    df = df.copy().sort_values([\"location\", \"date\"])\n    df[\"casos_semana\"] = (",
        "detail": "final_project.src.final_project.assets",
        "documentation": {}
    },
    {
        "label": "compute_factor_crec_7d",
        "kind": 2,
        "importPath": "final_project.src.final_project.assets",
        "description": "final_project.src.final_project.assets",
        "peekOfCode": "def compute_factor_crec_7d(df: pd.DataFrame) -> pd.DataFrame:\n    df = df.copy().sort_values([\"location\", \"date\"])\n    df[\"casos_semana\"] = (\n        df.groupby(\"location\")[\"new_cases\"].transform(lambda s: s.rolling(7, min_periods=7).sum())\n    )\n    df[\"casos_semana_prev\"] = (\n        df.groupby(\"location\")[\"new_cases\"].transform(lambda s: s.shift(7).rolling(7, min_periods=7).sum())\n    )\n    df[\"factor_crec_7d\"] = df[\"casos_semana\"] / df[\"casos_semana_prev\"]\n    out = df[[\"date\", \"location\", \"casos_semana\", \"factor_crec_7d\"]].dropna()",
        "detail": "final_project.src.final_project.assets",
        "documentation": {}
    },
    {
        "label": "leer_datos",
        "kind": 2,
        "importPath": "final_project.src.final_project.assets",
        "description": "final_project.src.final_project.assets",
        "peekOfCode": "def leer_datos(context) -> pd.DataFrame:\n    os.makedirs(OUTPUT_DIR, exist_ok=True)\n    if OWID_LOCAL_PATH and os.path.exists(OWID_LOCAL_PATH):\n        context.log.info(f\"Leyendo CSV local: {OWID_LOCAL_PATH}\")\n        df = pd.read_csv(OWID_LOCAL_PATH)\n    else:\n        context.log.info(f\"Descargando CSV desde: {OWID_URL}\")\n        resp = requests.get(OWID_URL, timeout=60)\n        resp.raise_for_status()\n        df = pd.read_csv(pyio.BytesIO(resp.content))",
        "detail": "final_project.src.final_project.assets",
        "documentation": {}
    },
    {
        "label": "tabla_perfilado",
        "kind": 2,
        "importPath": "final_project.src.final_project.assets",
        "description": "final_project.src.final_project.assets",
        "peekOfCode": "def tabla_perfilado(context, leer_datos: pd.DataFrame) -> pd.DataFrame:\n    df = leer_datos.copy()\n    df[\"date\"] = pd.to_datetime(df[\"date\"], errors=\"coerce\", utc=True).dt.tz_convert(None)\n    new_cases = pd.to_numeric(df[\"new_cases\"], errors=\"coerce\")\n    people_vacc = pd.to_numeric(df[\"people_vaccinated\"], errors=\"coerce\")\n    perfil = pd.DataFrame([\n        {\"metric\": \"filas\", \"valor\": len(df)},\n        {\"metric\": \"columnas\", \"valor\": len(df.columns)},\n        {\"metric\": \"new_cases_min\", \"valor\": float(new_cases.min(skipna=True))},\n        {\"metric\": \"new_cases_max\", \"valor\": float(new_cases.max(skipna=True))},",
        "detail": "final_project.src.final_project.assets",
        "documentation": {}
    },
    {
        "label": "datos_procesados",
        "kind": 2,
        "importPath": "final_project.src.final_project.assets",
        "description": "final_project.src.final_project.assets",
        "peekOfCode": "def datos_procesados(context, leer_datos: pd.DataFrame) -> pd.DataFrame:\n    df = procesar_base(leer_datos, \"Ecuador\", COMPARISON_COUNTRY)\n    context.log.info(f\"Procesado: {len(df):,} filas. Países: Ecuador y {COMPARISON_COUNTRY}\")\n    return df\n@asset(description=\"Incidencia acumulada a 7 días por 100k habitantes.\")\ndef metrica_incidencia_7d(context, datos_procesados: pd.DataFrame) -> pd.DataFrame:\n    out = compute_incidencia_7d(datos_procesados)\n    context.log.info(f\"Incidencia 7d -> {len(out):,} filas.\")\n    return out\n@asset(description=\"Factor de crecimiento semanal (últimos 7 días / semana previa).\")",
        "detail": "final_project.src.final_project.assets",
        "documentation": {}
    },
    {
        "label": "metrica_incidencia_7d",
        "kind": 2,
        "importPath": "final_project.src.final_project.assets",
        "description": "final_project.src.final_project.assets",
        "peekOfCode": "def metrica_incidencia_7d(context, datos_procesados: pd.DataFrame) -> pd.DataFrame:\n    out = compute_incidencia_7d(datos_procesados)\n    context.log.info(f\"Incidencia 7d -> {len(out):,} filas.\")\n    return out\n@asset(description=\"Factor de crecimiento semanal (últimos 7 días / semana previa).\")\ndef metrica_factor_crec_7d(context, datos_procesados: pd.DataFrame) -> pd.DataFrame:\n    out = compute_factor_crec_7d(datos_procesados)\n    context.log.info(f\"Factor crecimiento 7d -> {len(out):,} filas.\")\n    return out\n@asset(description=\"Exporta resultados finales a un Excel multipestaña.\")",
        "detail": "final_project.src.final_project.assets",
        "documentation": {}
    },
    {
        "label": "metrica_factor_crec_7d",
        "kind": 2,
        "importPath": "final_project.src.final_project.assets",
        "description": "final_project.src.final_project.assets",
        "peekOfCode": "def metrica_factor_crec_7d(context, datos_procesados: pd.DataFrame) -> pd.DataFrame:\n    out = compute_factor_crec_7d(datos_procesados)\n    context.log.info(f\"Factor crecimiento 7d -> {len(out):,} filas.\")\n    return out\n@asset(description=\"Exporta resultados finales a un Excel multipestaña.\")\ndef reporte_excel_covid(\n    context,\n    datos_procesados: pd.DataFrame,\n    metrica_incidencia_7d: pd.DataFrame,\n    metrica_factor_crec_7d: pd.DataFrame,",
        "detail": "final_project.src.final_project.assets",
        "documentation": {}
    },
    {
        "label": "reporte_excel_covid",
        "kind": 2,
        "importPath": "final_project.src.final_project.assets",
        "description": "final_project.src.final_project.assets",
        "peekOfCode": "def reporte_excel_covid(\n    context,\n    datos_procesados: pd.DataFrame,\n    metrica_incidencia_7d: pd.DataFrame,\n    metrica_factor_crec_7d: pd.DataFrame,\n) -> str:\n    os.makedirs(OUTPUT_DIR, exist_ok=True)\n    out_xlsx = os.path.join(OUTPUT_DIR, \"reporte_covid.xlsx\")\n    with pd.ExcelWriter(out_xlsx, engine=\"openpyxl\") as writer:\n        datos_procesados.to_excel(writer, sheet_name=\"datos_procesados\", index=False)",
        "detail": "final_project.src.final_project.assets",
        "documentation": {}
    },
    {
        "label": "check_no_future_dates",
        "kind": 2,
        "importPath": "final_project.src.final_project.assets",
        "description": "final_project.src.final_project.assets",
        "peekOfCode": "def check_no_future_dates(context, leer_datos: pd.DataFrame) -> AssetCheckResult:\n    d = _scope_rows(leer_datos)\n    d[\"date\"] = pd.to_datetime(d[\"date\"], errors=\"coerce\", utc=True).dt.tz_convert(None)\n    # Sólo filas con datos reales\n    has_data = pd.to_numeric(d.get(\"new_cases\"), errors=\"coerce\").notna()\n    d = d.loc[has_data]\n    max_date = d[\"date\"].max()\n    today = pd.Timestamp.utcnow().tz_localize(None).normalize()\n    n_future = int((d[\"date\"] > today).sum())\n    passed = pd.isna(max_date) or (max_date <= today)",
        "detail": "final_project.src.final_project.assets",
        "documentation": {}
    },
    {
        "label": "check_key_columns_not_null",
        "kind": 2,
        "importPath": "final_project.src.final_project.assets",
        "description": "final_project.src.final_project.assets",
        "peekOfCode": "def check_key_columns_not_null(context, leer_datos: pd.DataFrame) -> AssetCheckResult:\n    loc = _loc_col(leer_datos)\n    d = _scope_rows(leer_datos)\n    req_cols = [loc, \"date\", \"population\"]\n    subset_nulls = {c: int(d[c].isna().sum()) for c in req_cols if c in d.columns}\n    global_pop_nulls = int(pd.to_numeric(leer_datos.get(\"population\"), errors=\"coerce\").isna().sum())\n    passed = all(subset_nulls.get(c, 1) == 0 for c in req_cols)\n    return AssetCheckResult(\n        passed=passed,\n        metadata={",
        "detail": "final_project.src.final_project.assets",
        "documentation": {}
    },
    {
        "label": "check_unique_location_date",
        "kind": 2,
        "importPath": "final_project.src.final_project.assets",
        "description": "final_project.src.final_project.assets",
        "peekOfCode": "def check_unique_location_date(context, leer_datos: pd.DataFrame) -> AssetCheckResult:\n    loc = _loc_col(leer_datos)\n    if not {loc, \"date\"}.issubset(leer_datos.columns):\n        return AssetCheckResult(passed=False, metadata={\"error\": f\"Faltan columnas {loc} o date\"})\n    dupes = int(leer_datos.duplicated(subset=[loc, \"date\"]).sum())\n    return AssetCheckResult(passed=(dupes == 0), metadata={\"duplicados\": dupes})\n@asset_check(asset=\"leer_datos\", description=\"Población > 0.\")\ndef check_population_positive(context, leer_datos: pd.DataFrame) -> AssetCheckResult:\n    pop = pd.to_numeric(leer_datos.get(\"population\"), errors=\"coerce\")\n    non_pos = int((pop <= 0).sum()) if pop is not None else -1",
        "detail": "final_project.src.final_project.assets",
        "documentation": {}
    },
    {
        "label": "check_population_positive",
        "kind": 2,
        "importPath": "final_project.src.final_project.assets",
        "description": "final_project.src.final_project.assets",
        "peekOfCode": "def check_population_positive(context, leer_datos: pd.DataFrame) -> AssetCheckResult:\n    pop = pd.to_numeric(leer_datos.get(\"population\"), errors=\"coerce\")\n    non_pos = int((pop <= 0).sum()) if pop is not None else -1\n    passed = (non_pos == 0) if pop is not None else False\n    return AssetCheckResult(passed=passed, metadata={\"poblacion_no_positiva\": non_pos})\n@asset_check(asset=\"leer_datos\", description=\"Política de negativos en new_cases.\")\ndef check_new_cases_policy(context, leer_datos: pd.DataFrame) -> AssetCheckResult:\n    new_cases = pd.to_numeric(leer_datos.get(\"new_cases\"), errors=\"coerce\")\n    neg_count = int((new_cases < 0).sum()) if new_cases is not None else -1\n    if ALLOW_NEG:",
        "detail": "final_project.src.final_project.assets",
        "documentation": {}
    },
    {
        "label": "check_new_cases_policy",
        "kind": 2,
        "importPath": "final_project.src.final_project.assets",
        "description": "final_project.src.final_project.assets",
        "peekOfCode": "def check_new_cases_policy(context, leer_datos: pd.DataFrame) -> AssetCheckResult:\n    new_cases = pd.to_numeric(leer_datos.get(\"new_cases\"), errors=\"coerce\")\n    neg_count = int((new_cases < 0).sum()) if new_cases is not None else -1\n    if ALLOW_NEG:\n        passed = True\n        note = \"Negativos permitidos (ALLOW_NEGATIVE_NEW_CASES=true).\"\n    else:\n        passed = (neg_count == 0)\n        note = \"Negativos NO permitidos. Ajusta ALLOW_NEGATIVE_NEW_CASES si corresponde.\"\n    return AssetCheckResult(passed=passed, metadata={\"negativos\": neg_count, \"nota\": note})",
        "detail": "final_project.src.final_project.assets",
        "documentation": {}
    },
    {
        "label": "check_incidencia_7d_rango",
        "kind": 2,
        "importPath": "final_project.src.final_project.assets",
        "description": "final_project.src.final_project.assets",
        "peekOfCode": "def check_incidencia_7d_rango(context, metrica_incidencia_7d: pd.DataFrame) -> AssetCheckResult:\n    vals = pd.to_numeric(metrica_incidencia_7d[\"incidencia_7d\"], errors=\"coerce\")\n    outliers = int(((vals < 0) | (vals > 2000)).sum())\n    return AssetCheckResult(passed=(outliers == 0), metadata={\"fuera_de_rango\": outliers})",
        "detail": "final_project.src.final_project.assets",
        "documentation": {}
    },
    {
        "label": "OWID_URL",
        "kind": 5,
        "importPath": "final_project.src.final_project.assets",
        "description": "final_project.src.final_project.assets",
        "peekOfCode": "OWID_URL = os.getenv(\n    \"OWID_URL\",\n    \"https://catalog.ourworldindata.org/garden/covid/latest/compact/compact.csv\",\n)\nOWID_LOCAL_PATH = os.getenv(\"OWID_LOCAL_PATH\", \"\")\nCOMPARISON_COUNTRY = os.getenv(\"COMPARISON_COUNTRY\", \"Peru\")\nALLOW_NEG = os.getenv(\"ALLOW_NEGATIVE_NEW_CASES\", \"false\").lower() == \"true\"\nOUTPUT_DIR = os.getenv(\"OUTPUT_DIR\", \"final_project/output\")\n# =========================\n# Helpers",
        "detail": "final_project.src.final_project.assets",
        "documentation": {}
    },
    {
        "label": "OWID_LOCAL_PATH",
        "kind": 5,
        "importPath": "final_project.src.final_project.assets",
        "description": "final_project.src.final_project.assets",
        "peekOfCode": "OWID_LOCAL_PATH = os.getenv(\"OWID_LOCAL_PATH\", \"\")\nCOMPARISON_COUNTRY = os.getenv(\"COMPARISON_COUNTRY\", \"Peru\")\nALLOW_NEG = os.getenv(\"ALLOW_NEGATIVE_NEW_CASES\", \"false\").lower() == \"true\"\nOUTPUT_DIR = os.getenv(\"OUTPUT_DIR\", \"final_project/output\")\n# =========================\n# Helpers\n# =========================\ndef _loc_col(df: pd.DataFrame) -> str:\n    \"\"\"Devuelve el nombre de la columna de país según el dataset:\n    'location' (owid-covid-data) o 'country' (compact.csv).\"\"\"",
        "detail": "final_project.src.final_project.assets",
        "documentation": {}
    },
    {
        "label": "COMPARISON_COUNTRY",
        "kind": 5,
        "importPath": "final_project.src.final_project.assets",
        "description": "final_project.src.final_project.assets",
        "peekOfCode": "COMPARISON_COUNTRY = os.getenv(\"COMPARISON_COUNTRY\", \"Peru\")\nALLOW_NEG = os.getenv(\"ALLOW_NEGATIVE_NEW_CASES\", \"false\").lower() == \"true\"\nOUTPUT_DIR = os.getenv(\"OUTPUT_DIR\", \"final_project/output\")\n# =========================\n# Helpers\n# =========================\ndef _loc_col(df: pd.DataFrame) -> str:\n    \"\"\"Devuelve el nombre de la columna de país según el dataset:\n    'location' (owid-covid-data) o 'country' (compact.csv).\"\"\"\n    if \"location\" in df.columns:",
        "detail": "final_project.src.final_project.assets",
        "documentation": {}
    },
    {
        "label": "ALLOW_NEG",
        "kind": 5,
        "importPath": "final_project.src.final_project.assets",
        "description": "final_project.src.final_project.assets",
        "peekOfCode": "ALLOW_NEG = os.getenv(\"ALLOW_NEGATIVE_NEW_CASES\", \"false\").lower() == \"true\"\nOUTPUT_DIR = os.getenv(\"OUTPUT_DIR\", \"final_project/output\")\n# =========================\n# Helpers\n# =========================\ndef _loc_col(df: pd.DataFrame) -> str:\n    \"\"\"Devuelve el nombre de la columna de país según el dataset:\n    'location' (owid-covid-data) o 'country' (compact.csv).\"\"\"\n    if \"location\" in df.columns:\n        return \"location\"",
        "detail": "final_project.src.final_project.assets",
        "documentation": {}
    },
    {
        "label": "OUTPUT_DIR",
        "kind": 5,
        "importPath": "final_project.src.final_project.assets",
        "description": "final_project.src.final_project.assets",
        "peekOfCode": "OUTPUT_DIR = os.getenv(\"OUTPUT_DIR\", \"final_project/output\")\n# =========================\n# Helpers\n# =========================\ndef _loc_col(df: pd.DataFrame) -> str:\n    \"\"\"Devuelve el nombre de la columna de país según el dataset:\n    'location' (owid-covid-data) o 'country' (compact.csv).\"\"\"\n    if \"location\" in df.columns:\n        return \"location\"\n    if \"country\" in df.columns:",
        "detail": "final_project.src.final_project.assets",
        "documentation": {}
    },
    {
        "label": "defs",
        "kind": 5,
        "importPath": "final_project.src.final_project.definitions",
        "description": "final_project.src.final_project.definitions",
        "peekOfCode": "defs = Definitions(\n    assets=load_assets_from_modules([assets_module]),\n    asset_checks=[\n        assets_module.check_no_future_dates,\n        assets_module.check_key_columns_not_null,\n        assets_module.check_unique_location_date,\n        assets_module.check_population_positive,\n        assets_module.check_new_cases_policy,\n        assets_module.check_incidencia_7d_rango,\n    ],",
        "detail": "final_project.src.final_project.definitions",
        "documentation": {}
    },
    {
        "label": "CantidadInvalida",
        "kind": 6,
        "importPath": "labs.lab1.main",
        "description": "labs.lab1.main",
        "peekOfCode": "class CantidadInvalida(Exception):\n    \"\"\"Se lanza cuando la cantidad es menor o igual a 0.\"\"\"\n    pass\ndef calcular_total(precio_unitario: float, cantidad: int) -> float:\n    \"\"\"\n    - Lanza CantidadInvalida si cantidad <= 0\n    - Lanza ValueError si precio_unitario < 0\n    - Devuelve precio_unitario * cantidad en caso válido\n    \"\"\"\n    if cantidad <= 0:",
        "detail": "labs.lab1.main",
        "documentation": {}
    },
    {
        "label": "saludar",
        "kind": 2,
        "importPath": "labs.lab1.main",
        "description": "labs.lab1.main",
        "peekOfCode": "def saludar(nombre: str) -> str:\n    return f\"Hola, {nombre}\"\ndef despedir(nombre: str) -> str:\n    return f\"Adiós, {nombre}\"\ndef aplaudir(nombre: str, veces: int = 3, emoji: str = \"👏\") -> str:\n    return f\"{nombre}: \" + (emoji * veces)\n# Diccionario que mapea nombres a funciones (funciones como valores)\nacciones: Dict[str, Callable[..., Any]] = {\n    \"saludar\": saludar,\n    \"despedir\": despedir,",
        "detail": "labs.lab1.main",
        "documentation": {}
    },
    {
        "label": "despedir",
        "kind": 2,
        "importPath": "labs.lab1.main",
        "description": "labs.lab1.main",
        "peekOfCode": "def despedir(nombre: str) -> str:\n    return f\"Adiós, {nombre}\"\ndef aplaudir(nombre: str, veces: int = 3, emoji: str = \"👏\") -> str:\n    return f\"{nombre}: \" + (emoji * veces)\n# Diccionario que mapea nombres a funciones (funciones como valores)\nacciones: Dict[str, Callable[..., Any]] = {\n    \"saludar\": saludar,\n    \"despedir\": despedir,\n    \"aplaudir\": aplaudir,\n}",
        "detail": "labs.lab1.main",
        "documentation": {}
    },
    {
        "label": "aplaudir",
        "kind": 2,
        "importPath": "labs.lab1.main",
        "description": "labs.lab1.main",
        "peekOfCode": "def aplaudir(nombre: str, veces: int = 3, emoji: str = \"👏\") -> str:\n    return f\"{nombre}: \" + (emoji * veces)\n# Diccionario que mapea nombres a funciones (funciones como valores)\nacciones: Dict[str, Callable[..., Any]] = {\n    \"saludar\": saludar,\n    \"despedir\": despedir,\n    \"aplaudir\": aplaudir,\n}\ndef ejecutar(accion: str, *args, **kwargs) -> Any:\n    \"\"\"",
        "detail": "labs.lab1.main",
        "documentation": {}
    },
    {
        "label": "ejecutar",
        "kind": 2,
        "importPath": "labs.lab1.main",
        "description": "labs.lab1.main",
        "peekOfCode": "def ejecutar(accion: str, *args, **kwargs) -> Any:\n    \"\"\"\n    Busca la función por nombre en 'acciones' y la ejecuta con *args/**kwargs.\n    Lanza ValueError si la acción no existe.\n    \"\"\"\n    try:\n        funcion = acciones[accion]\n    except KeyError:\n        disponibles = \", \".join(sorted(acciones.keys()))\n        raise ValueError(f\"Acción desconocida: '{accion}'. Opciones: {disponibles}\")",
        "detail": "labs.lab1.main",
        "documentation": {}
    },
    {
        "label": "crear_descuento",
        "kind": 2,
        "importPath": "labs.lab1.main",
        "description": "labs.lab1.main",
        "peekOfCode": "def crear_descuento(porcentaje: float) -> Callable[[float], float]:\n    \"\"\"\n    Devuelve una función que aplica el descuento 'porcentaje' (por ejemplo 0.10 = 10%)\n    sobre un precio recibido.\n    \"\"\"\n    def aplicar(precio: float) -> float:\n        return round(precio * (1 - porcentaje), 2)\n    return aplicar\n# =========================\n# MÓDULO B — EXCEPCIONES",
        "detail": "labs.lab1.main",
        "documentation": {}
    },
    {
        "label": "parsear_enteros",
        "kind": 2,
        "importPath": "labs.lab1.main",
        "description": "labs.lab1.main",
        "peekOfCode": "def parsear_enteros(entradas: List[str]) -> Tuple[List[int], List[str]]:\n    \"\"\"\n    Convierte cada string a entero. Si alguno falla, registra un mensaje de error.\n    Retorna (valores_convertidos, mensajes_error).\n    El proceso continúa aunque haya errores.\n    \"\"\"\n    valores: List[int] = []\n    errores: List[str] = []\n    for i, s in enumerate(entradas):\n        try:",
        "detail": "labs.lab1.main",
        "documentation": {}
    },
    {
        "label": "calcular_total",
        "kind": 2,
        "importPath": "labs.lab1.main",
        "description": "labs.lab1.main",
        "peekOfCode": "def calcular_total(precio_unitario: float, cantidad: int) -> float:\n    \"\"\"\n    - Lanza CantidadInvalida si cantidad <= 0\n    - Lanza ValueError si precio_unitario < 0\n    - Devuelve precio_unitario * cantidad en caso válido\n    \"\"\"\n    if cantidad <= 0:\n        raise CantidadInvalida(f\"La cantidad debe ser > 0. Recibido: {cantidad}\")\n    if precio_unitario < 0:\n        raise ValueError(f\"El precio unitario no puede ser negativo. Recibido: {precio_unitario}\")",
        "detail": "labs.lab1.main",
        "documentation": {}
    },
    {
        "label": "requiere_positivos",
        "kind": 2,
        "importPath": "labs.lab1.main",
        "description": "labs.lab1.main",
        "peekOfCode": "def requiere_positivos(func: Callable[..., Any]) -> Callable[..., Any]:\n    \"\"\"\n    Verifica que todos los argumentos numéricos (posicionales y nombrados)\n    sean > 0; si no, lanza ValueError con un mensaje útil.\n    \"\"\"\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        def es_numero(x: Any) -> bool:\n            return isinstance(x, (int, float)) and not isinstance(x, bool)\n        # Revisar *args",
        "detail": "labs.lab1.main",
        "documentation": {}
    },
    {
        "label": "calcular_descuento",
        "kind": 2,
        "importPath": "labs.lab1.main",
        "description": "labs.lab1.main",
        "peekOfCode": "def calcular_descuento(precio: float, porcentaje: float) -> float:\n    \"\"\"\n    Aplica un descuento (por ejemplo 0.2 = 20%) a 'precio'.\n    Requiere que ambos sean positivos (> 0).\n    \"\"\"\n    return round(precio * (1 - porcentaje), 2)\n@requiere_positivos\ndef escala(valor: float, factor: float) -> float:\n    \"\"\"Multiplica 'valor' por 'factor'. Ambos deben ser > 0.\"\"\"\n    return valor * factor",
        "detail": "labs.lab1.main",
        "documentation": {}
    },
    {
        "label": "escala",
        "kind": 2,
        "importPath": "labs.lab1.main",
        "description": "labs.lab1.main",
        "peekOfCode": "def escala(valor: float, factor: float) -> float:\n    \"\"\"Multiplica 'valor' por 'factor'. Ambos deben ser > 0.\"\"\"\n    return valor * factor\n# =========================\n# DEMOS / AUTOPRUEBAS SENCILLAS\n# =========================\ndef _demo_modulo_a():\n    print(\"\\n=== Módulo A ===\")\n    # A.1\n    print(\"A.1 – ejecutar('saludar', 'Ana'):\")",
        "detail": "labs.lab1.main",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "labs.lab1.main",
        "description": "labs.lab1.main",
        "peekOfCode": "def main():\n    _demo_modulo_a()\n    _demo_modulo_b()\n    _demo_modulo_c()\n    print(\"\\n✅ Todas las verificaciones básicas del Lab 1 pasaron.\")\nif __name__ == \"__main__\":\n    main()",
        "detail": "labs.lab1.main",
        "documentation": {}
    },
    {
        "label": "normalize",
        "kind": 2,
        "importPath": "labs.lab2.textkit.cleaners",
        "description": "labs.lab2.textkit.cleaners",
        "peekOfCode": "def normalize(s: str) -> str:\n    \"\"\"Similar a normalizar(): sin acentos, minúsculas, espacios colapsados.\"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"normalize() espera un str\")\n    s = _strip_accents(s).lower().strip()\n    s = \" \".join(s.split())\n    return s\ndef slugify(s: str, max_len: int = 60) -> str:\n    \"\"\"Slug simple reutilizable en el paquete.\"\"\"\n    s = normalize(s)",
        "detail": "labs.lab2.textkit.cleaners",
        "documentation": {}
    },
    {
        "label": "slugify",
        "kind": 2,
        "importPath": "labs.lab2.textkit.cleaners",
        "description": "labs.lab2.textkit.cleaners",
        "peekOfCode": "def slugify(s: str, max_len: int = 60) -> str:\n    \"\"\"Slug simple reutilizable en el paquete.\"\"\"\n    s = normalize(s)\n    s = s.replace(\"_\", \"-\").replace(\" \", \"-\")\n    s = re.sub(r\"[^a-z0-9\\-]\", \"\", s)\n    s = re.sub(r\"-{2,}\", \"-\", s).strip(\"-\")\n    if not s:\n        raise ValueError(\"slugify(): quedó vacío\")\n    return s[:max_len]",
        "detail": "labs.lab2.textkit.cleaners",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "labs.lab2.textkit.cleaners",
        "description": "labs.lab2.textkit.cleaners",
        "peekOfCode": "__all__ = [\"normalize\", \"slugify\"]\ndef _strip_accents(s: str) -> str:\n    nf = unicodedata.normalize(\"NFD\", s)\n    return \"\".join(ch for ch in nf if unicodedata.category(ch) != \"Mn\")\ndef normalize(s: str) -> str:\n    \"\"\"Similar a normalizar(): sin acentos, minúsculas, espacios colapsados.\"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"normalize() espera un str\")\n    s = _strip_accents(s).lower().strip()\n    s = \" \".join(s.split())",
        "detail": "labs.lab2.textkit.cleaners",
        "documentation": {}
    },
    {
        "label": "is_slug",
        "kind": 2,
        "importPath": "labs.lab2.textkit.validators",
        "description": "labs.lab2.textkit.validators",
        "peekOfCode": "def is_slug(s: str) -> bool:\n    \"\"\"Valida si 's' es un slug válido.\"\"\"\n    return bool(_SLUG.fullmatch(s))\ndef require_non_empty(s: str) -> str:\n    \"\"\"Exige que el texto no sea vacío (tras normalize + strip).\"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"require_non_empty() espera un str\")\n    if normalize(s) == \"\":\n        raise ValueError(\"El texto no debe ser vacío\")\n    return s",
        "detail": "labs.lab2.textkit.validators",
        "documentation": {}
    },
    {
        "label": "require_non_empty",
        "kind": 2,
        "importPath": "labs.lab2.textkit.validators",
        "description": "labs.lab2.textkit.validators",
        "peekOfCode": "def require_non_empty(s: str) -> str:\n    \"\"\"Exige que el texto no sea vacío (tras normalize + strip).\"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"require_non_empty() espera un str\")\n    if normalize(s) == \"\":\n        raise ValueError(\"El texto no debe ser vacío\")\n    return s",
        "detail": "labs.lab2.textkit.validators",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "labs.lab2.textkit.validators",
        "description": "labs.lab2.textkit.validators",
        "peekOfCode": "__all__ = [\"is_slug\", \"require_non_empty\"]\n_SLUG = re.compile(r\"^[a-z0-9]+(?:-[a-z0-9]+)*$\")\ndef is_slug(s: str) -> bool:\n    \"\"\"Valida si 's' es un slug válido.\"\"\"\n    return bool(_SLUG.fullmatch(s))\ndef require_non_empty(s: str) -> str:\n    \"\"\"Exige que el texto no sea vacío (tras normalize + strip).\"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"require_non_empty() espera un str\")\n    if normalize(s) == \"\":",
        "detail": "labs.lab2.textkit.validators",
        "documentation": {}
    },
    {
        "label": "_SLUG",
        "kind": 5,
        "importPath": "labs.lab2.textkit.validators",
        "description": "labs.lab2.textkit.validators",
        "peekOfCode": "_SLUG = re.compile(r\"^[a-z0-9]+(?:-[a-z0-9]+)*$\")\ndef is_slug(s: str) -> bool:\n    \"\"\"Valida si 's' es un slug válido.\"\"\"\n    return bool(_SLUG.fullmatch(s))\ndef require_non_empty(s: str) -> str:\n    \"\"\"Exige que el texto no sea vacío (tras normalize + strip).\"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"require_non_empty() espera un str\")\n    if normalize(s) == \"\":\n        raise ValueError(\"El texto no debe ser vacío\")",
        "detail": "labs.lab2.textkit.validators",
        "documentation": {}
    },
    {
        "label": "demo_parte_a",
        "kind": 2,
        "importPath": "labs.lab2.main",
        "description": "labs.lab2.main",
        "peekOfCode": "def demo_parte_a():\n    print(\"\\n=== PARTE A — MÓDULO 'modulo_cadenas' ===\")\n    texto = \"  ¡Hola Mundo Ágil!  \"\n    print(\"normalizar:\", mc.normalizar(texto))\n    print(\"slugify:\", mc.slugify(texto))\n    s_ok = \"hola-mundo-agil\"\n    s_bad = \"Hola Mundo!!!\"\n    print(\"es_slug(s_ok):\", mc.es_slug(s_ok))\n    print(\"es_slug(s_bad):\", mc.es_slug(s_bad))\n    # Caso límite (error controlado)",
        "detail": "labs.lab2.main",
        "documentation": {}
    },
    {
        "label": "demo_parte_b",
        "kind": 2,
        "importPath": "labs.lab2.main",
        "description": "labs.lab2.main",
        "peekOfCode": "def demo_parte_b():\n    print(\"\\n=== PARTE B — PAQUETE 'textkit' ===\")\n    # Usando API pública reexportada por __init__.py (importación absoluta)\n    texto = \"  Programación en PYTHON — Módulos y Paquetes  \"\n    print(\"pkg_normalize:\", pkg_normalize(texto))\n    slug = pkg_slugify(texto)\n    print(\"pkg_slugify:\", slug)\n    print(\"pkg_is_slug(slug):\", pkg_is_slug(slug))\n    # Caso límite (error controlado)\n    try:",
        "detail": "labs.lab2.main",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "labs.lab2.main",
        "description": "labs.lab2.main",
        "peekOfCode": "def main():\n    demo_parte_a()\n    demo_parte_b()\n    print(\"\\n✅ Lab 2 ejecutado correctamente.\")\nif __name__ == \"__main__\":\n    main()",
        "detail": "labs.lab2.main",
        "documentation": {}
    },
    {
        "label": "normalizar",
        "kind": 2,
        "importPath": "labs.lab2.modulo_cadenas",
        "description": "labs.lab2.modulo_cadenas",
        "peekOfCode": "def normalizar(texto: str) -> str:\n    \"\"\"\n    - Quita acentos\n    - Convierte a minúsculas\n    - Colapsa espacios en uno solo\n    - Elimina espacios al inicio/fin\n    \"\"\"\n    if not isinstance(texto, str):\n        raise TypeError(\"normalizar() espera un str\")\n    texto = _quitar_acentos(texto).lower().strip()",
        "detail": "labs.lab2.modulo_cadenas",
        "documentation": {}
    },
    {
        "label": "slugify",
        "kind": 2,
        "importPath": "labs.lab2.modulo_cadenas",
        "description": "labs.lab2.modulo_cadenas",
        "peekOfCode": "def slugify(texto: str, max_len: int = 60) -> str:\n    \"\"\"\n    Convierte un texto en 'slug' (kebab-case):\n    - normaliza (sin acentos, minúsculas)\n    - reemplaza espacios/guiones bajos por '-'\n    - remueve caracteres no alfanuméricos ni '-'\n    - colapsa guiones repetidos y recorta a max_len\n    - lanza ValueError si queda vacío\n    \"\"\"\n    base = normalizar(texto)",
        "detail": "labs.lab2.modulo_cadenas",
        "documentation": {}
    },
    {
        "label": "es_slug",
        "kind": 2,
        "importPath": "labs.lab2.modulo_cadenas",
        "description": "labs.lab2.modulo_cadenas",
        "peekOfCode": "def es_slug(texto: str) -> bool:\n    \"\"\"Valida si el texto cumple el patrón de slug simple.\"\"\"\n    return bool(_SLUG_RE.fullmatch(texto))\ndef requerir_no_vacio(texto: str) -> str:\n    \"\"\"\n    Verifica que el string no esté vacío (tras strip()).\n    Lanza ValueError con mensaje claro si no cumple.\n    \"\"\"\n    if not isinstance(texto, str):\n        raise TypeError(\"requerir_no_vacio() espera un str\")",
        "detail": "labs.lab2.modulo_cadenas",
        "documentation": {}
    },
    {
        "label": "requerir_no_vacio",
        "kind": 2,
        "importPath": "labs.lab2.modulo_cadenas",
        "description": "labs.lab2.modulo_cadenas",
        "peekOfCode": "def requerir_no_vacio(texto: str) -> str:\n    \"\"\"\n    Verifica que el string no esté vacío (tras strip()).\n    Lanza ValueError con mensaje claro si no cumple.\n    \"\"\"\n    if not isinstance(texto, str):\n        raise TypeError(\"requerir_no_vacio() espera un str\")\n    if texto.strip() == \"\":\n        raise ValueError(\"El texto no debe estar vacío\")\n    return texto",
        "detail": "labs.lab2.modulo_cadenas",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "labs.lab2.modulo_cadenas",
        "description": "labs.lab2.modulo_cadenas",
        "peekOfCode": "__all__ = [\"normalizar\", \"slugify\", \"es_slug\", \"requerir_no_vacio\"]\ndef _quitar_acentos(texto: str) -> str:\n    nfkd = unicodedata.normalize(\"NFD\", texto)\n    return \"\".join(ch for ch in nfkd if unicodedata.category(ch) != \"Mn\")\ndef normalizar(texto: str) -> str:\n    \"\"\"\n    - Quita acentos\n    - Convierte a minúsculas\n    - Colapsa espacios en uno solo\n    - Elimina espacios al inicio/fin",
        "detail": "labs.lab2.modulo_cadenas",
        "documentation": {}
    },
    {
        "label": "_SLUG_RE",
        "kind": 5,
        "importPath": "labs.lab2.modulo_cadenas",
        "description": "labs.lab2.modulo_cadenas",
        "peekOfCode": "_SLUG_RE = re.compile(r\"^[a-z0-9]+(?:-[a-z0-9]+)*$\")\ndef es_slug(texto: str) -> bool:\n    \"\"\"Valida si el texto cumple el patrón de slug simple.\"\"\"\n    return bool(_SLUG_RE.fullmatch(texto))\ndef requerir_no_vacio(texto: str) -> str:\n    \"\"\"\n    Verifica que el string no esté vacío (tras strip()).\n    Lanza ValueError con mensaje claro si no cumple.\n    \"\"\"\n    if not isinstance(texto, str):",
        "detail": "labs.lab2.modulo_cadenas",
        "documentation": {}
    },
    {
        "label": "demo",
        "kind": 2,
        "importPath": "labs.lab3.src.main",
        "description": "labs.lab3.src.main",
        "peekOfCode": "def demo():\n    print(\"=== Demo Lab 3: operaciones ===\")\n    print(\"suma(10, 5) ->\", suma(10, 5))\n    try:\n        print(\"division(10, 2) ->\", division(10, 2))\n        print(\"division(10, 0) -> (debe fallar)\")\n        print(division(10, 0))  # caso límite: dispara ValueError\n    except ValueError as e:\n        print(\"OK, error controlado:\", e)\ndef main():",
        "detail": "labs.lab3.src.main",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "labs.lab3.src.main",
        "description": "labs.lab3.src.main",
        "peekOfCode": "def main():\n    demo()\n    print(\"\\n✅ Lab 3 ejecutado correctamente desde main.py\")\nif __name__ == \"__main__\":\n    main()",
        "detail": "labs.lab3.src.main",
        "documentation": {}
    },
    {
        "label": "suma",
        "kind": 2,
        "importPath": "labs.lab3.src.operaciones",
        "description": "labs.lab3.src.operaciones",
        "peekOfCode": "def suma(a: float, b: float) -> float:\n    \"\"\"Suma dos números (float|int) y retorna float.\"\"\"\n    return float(a) + float(b)\ndef division(a: float, b: float) -> float:\n    \"\"\"Divide a entre b. Lanza ValueError si b == 0.\"\"\"\n    if b == 0:\n        raise ValueError(\"La división por cero no está permitida.\")\n    return float(a) / float(b)",
        "detail": "labs.lab3.src.operaciones",
        "documentation": {}
    },
    {
        "label": "division",
        "kind": 2,
        "importPath": "labs.lab3.src.operaciones",
        "description": "labs.lab3.src.operaciones",
        "peekOfCode": "def division(a: float, b: float) -> float:\n    \"\"\"Divide a entre b. Lanza ValueError si b == 0.\"\"\"\n    if b == 0:\n        raise ValueError(\"La división por cero no está permitida.\")\n    return float(a) / float(b)",
        "detail": "labs.lab3.src.operaciones",
        "documentation": {}
    },
    {
        "label": "suma",
        "kind": 2,
        "importPath": "labs.lab3.src.operaciones_buggy",
        "description": "labs.lab3.src.operaciones_buggy",
        "peekOfCode": "def suma(a, b):  # sin anotaciones\n    return a + b\ndef division(a, b):  # sin anotaciones; devuelve None a veces\n    if b == 0:\n        return None  # mypy: retorno inconsistente / Optional no declarado\n    return a / b",
        "detail": "labs.lab3.src.operaciones_buggy",
        "documentation": {}
    },
    {
        "label": "division",
        "kind": 2,
        "importPath": "labs.lab3.src.operaciones_buggy",
        "description": "labs.lab3.src.operaciones_buggy",
        "peekOfCode": "def division(a, b):  # sin anotaciones; devuelve None a veces\n    if b == 0:\n        return None  # mypy: retorno inconsistente / Optional no declarado\n    return a / b",
        "detail": "labs.lab3.src.operaciones_buggy",
        "documentation": {}
    },
    {
        "label": "test_suma",
        "kind": 2,
        "importPath": "labs.lab3.tests.test_operaciones",
        "description": "labs.lab3.tests.test_operaciones",
        "peekOfCode": "def test_suma():\n    assert suma(2, 3) == 5.0\ndef test_division_ok():\n    assert division(10, 2) == 5.0\ndef test_division_cero():\n    with pytest.raises(ValueError):\n        division(1, 0)",
        "detail": "labs.lab3.tests.test_operaciones",
        "documentation": {}
    },
    {
        "label": "test_division_ok",
        "kind": 2,
        "importPath": "labs.lab3.tests.test_operaciones",
        "description": "labs.lab3.tests.test_operaciones",
        "peekOfCode": "def test_division_ok():\n    assert division(10, 2) == 5.0\ndef test_division_cero():\n    with pytest.raises(ValueError):\n        division(1, 0)",
        "detail": "labs.lab3.tests.test_operaciones",
        "documentation": {}
    },
    {
        "label": "test_division_cero",
        "kind": 2,
        "importPath": "labs.lab3.tests.test_operaciones",
        "description": "labs.lab3.tests.test_operaciones",
        "peekOfCode": "def test_division_cero():\n    with pytest.raises(ValueError):\n        division(1, 0)",
        "detail": "labs.lab3.tests.test_operaciones",
        "documentation": {}
    },
    {
        "label": "asegurar_dataset",
        "kind": 2,
        "importPath": "labs.lab4.main",
        "description": "labs.lab4.main",
        "peekOfCode": "def asegurar_dataset() -> None:\n    \"\"\"Crea un CSV pequeño si no existe.\"\"\"\n    if DATA_PATH.exists():\n        return\n    # Dataset de ejemplo (20 filas, con algunos nulos deliberados)\n    df = pd.DataFrame({\n        \"id\": range(1, 21),\n        \"fecha\": pd.date_range(\"2024-01-01\", periods=20, freq=\"D\"),\n        \"categoria\": [\"A\", \"B\", \"C\", \"A\", \"B\"] * 4,\n        \"producto\": [\"Prod1\", \"Prod2\", \"Prod3\", \"Prod4\"] * 5,",
        "detail": "labs.lab4.main",
        "documentation": {}
    },
    {
        "label": "parte_a_pandas",
        "kind": 2,
        "importPath": "labs.lab4.main",
        "description": "labs.lab4.main",
        "peekOfCode": "def parte_a_pandas():\n    print(\"\\n=== Parte A — pandas ===\")\n    df = pd.read_csv(DATA_PATH)\n    print(f\"[Exploración] Forma: {df.shape[0]} filas x {df.shape[1]} columnas\")\n    print(\"[Tipos]:\")\n    print(df.dtypes)\n    print(\"\\n[Nulos por columna]:\")\n    print(df.isna().sum())\n    # Columna clave (ejemplo): 'id' y 'fecha'\n    print(\"\\n[Columna clave] id (entero) y fecha (temporal)\")",
        "detail": "labs.lab4.main",
        "documentation": {}
    },
    {
        "label": "parte_b_duckdb",
        "kind": 2,
        "importPath": "labs.lab4.main",
        "description": "labs.lab4.main",
        "peekOfCode": "def parte_b_duckdb():\n    print(\"\\n=== Parte B — DuckDB (SQL embebido) ===\")\n    # B.1: primer query sobre el archivo (sin pasar por pandas)\n    cnt = duckdb.query(f\"SELECT COUNT(*) AS filas FROM read_csv_auto('{DATA_PATH.as_posix()}', HEADER=True);\").to_df()\n    print(\"[Conteo directo CSV con DuckDB]:\")\n    print(cnt)\n    # SELECT que replica el análisis de pandas:\n    # - Limpieza equivalente (precio nulo->0, cantidad nula->1, cliente trim/title, categoria upper)\n    # - Derivadas: importe, mes\n    # - Filtro: precio > 10",
        "detail": "labs.lab4.main",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "labs.lab4.main",
        "description": "labs.lab4.main",
        "peekOfCode": "def main():\n    asegurar_dataset()\n    parte_a_pandas()\n    parte_b_duckdb()\n    print(\"\\n✅ Lab 4 completado. Archivos en:\", OUT_DIR)\nif __name__ == \"__main__\":\n    main()",
        "detail": "labs.lab4.main",
        "documentation": {}
    },
    {
        "label": "ROOT",
        "kind": 5,
        "importPath": "labs.lab4.main",
        "description": "labs.lab4.main",
        "peekOfCode": "ROOT = Path(__file__).parent\nDATA_PATH = ROOT / \"ventas_demo.csv\"\nOUT_DIR = ROOT / \"output\"\nOUT_DIR.mkdir(parents=True, exist_ok=True)\ndef asegurar_dataset() -> None:\n    \"\"\"Crea un CSV pequeño si no existe.\"\"\"\n    if DATA_PATH.exists():\n        return\n    # Dataset de ejemplo (20 filas, con algunos nulos deliberados)\n    df = pd.DataFrame({",
        "detail": "labs.lab4.main",
        "documentation": {}
    },
    {
        "label": "DATA_PATH",
        "kind": 5,
        "importPath": "labs.lab4.main",
        "description": "labs.lab4.main",
        "peekOfCode": "DATA_PATH = ROOT / \"ventas_demo.csv\"\nOUT_DIR = ROOT / \"output\"\nOUT_DIR.mkdir(parents=True, exist_ok=True)\ndef asegurar_dataset() -> None:\n    \"\"\"Crea un CSV pequeño si no existe.\"\"\"\n    if DATA_PATH.exists():\n        return\n    # Dataset de ejemplo (20 filas, con algunos nulos deliberados)\n    df = pd.DataFrame({\n        \"id\": range(1, 21),",
        "detail": "labs.lab4.main",
        "documentation": {}
    },
    {
        "label": "OUT_DIR",
        "kind": 5,
        "importPath": "labs.lab4.main",
        "description": "labs.lab4.main",
        "peekOfCode": "OUT_DIR = ROOT / \"output\"\nOUT_DIR.mkdir(parents=True, exist_ok=True)\ndef asegurar_dataset() -> None:\n    \"\"\"Crea un CSV pequeño si no existe.\"\"\"\n    if DATA_PATH.exists():\n        return\n    # Dataset de ejemplo (20 filas, con algunos nulos deliberados)\n    df = pd.DataFrame({\n        \"id\": range(1, 21),\n        \"fecha\": pd.date_range(\"2024-01-01\", periods=20, freq=\"D\"),",
        "detail": "labs.lab4.main",
        "documentation": {}
    },
    {
        "label": "ValidationResult",
        "kind": 6,
        "importPath": "labs.lab5.src.csv_validation",
        "description": "labs.lab5.src.csv_validation",
        "peekOfCode": "class ValidationResult:\n    rows: int\n    errors: List[str]\ndef read_csv_rows(path: Path) -> List[Dict[str, str]]:\n    \"\"\"\n    Lee un CSV con encabezado y devuelve lista de dicts (valores en str).\n    \"\"\"\n    with path.open(\"r\", newline=\"\", encoding=\"utf-8\") as f:\n        reader = csv.DictReader(f)\n        return list(reader)",
        "detail": "labs.lab5.src.csv_validation",
        "documentation": {}
    },
    {
        "label": "read_csv_rows",
        "kind": 2,
        "importPath": "labs.lab5.src.csv_validation",
        "description": "labs.lab5.src.csv_validation",
        "peekOfCode": "def read_csv_rows(path: Path) -> List[Dict[str, str]]:\n    \"\"\"\n    Lee un CSV con encabezado y devuelve lista de dicts (valores en str).\n    \"\"\"\n    with path.open(\"r\", newline=\"\", encoding=\"utf-8\") as f:\n        reader = csv.DictReader(f)\n        return list(reader)\ndef validate_header(row_keys: Iterable[str]) -> List[str]:\n    \"\"\"\n    Valida que todas las columnas requeridas estén presentes.",
        "detail": "labs.lab5.src.csv_validation",
        "documentation": {}
    },
    {
        "label": "validate_header",
        "kind": 2,
        "importPath": "labs.lab5.src.csv_validation",
        "description": "labs.lab5.src.csv_validation",
        "peekOfCode": "def validate_header(row_keys: Iterable[str]) -> List[str]:\n    \"\"\"\n    Valida que todas las columnas requeridas estén presentes.\n    \"\"\"\n    keys = set(row_keys)\n    missing = [c for c in REQUIRED_COLUMNS if c not in keys]\n    return [f\"Falta columna obligatoria: {c}\" for c in missing]\ndef validate_types_and_rules(rows: List[Dict[str, str]]) -> List[str]:\n    \"\"\"\n    Reglas mínimas:",
        "detail": "labs.lab5.src.csv_validation",
        "documentation": {}
    },
    {
        "label": "validate_types_and_rules",
        "kind": 2,
        "importPath": "labs.lab5.src.csv_validation",
        "description": "labs.lab5.src.csv_validation",
        "peekOfCode": "def validate_types_and_rules(rows: List[Dict[str, str]]) -> List[str]:\n    \"\"\"\n    Reglas mínimas:\n    - id entero, único y >= 1\n    - name no vacío\n    - age entero >= 0\n    - score float >= 0\n    \"\"\"\n    errors: List[str] = []\n    seen_ids = set()",
        "detail": "labs.lab5.src.csv_validation",
        "documentation": {}
    },
    {
        "label": "validate_csv",
        "kind": 2,
        "importPath": "labs.lab5.src.csv_validation",
        "description": "labs.lab5.src.csv_validation",
        "peekOfCode": "def validate_csv(path: Path) -> ValidationResult:\n    rows = read_csv_rows(path)\n    header_errors = validate_header(rows[0].keys() if rows else REQUIRED_COLUMNS)\n    data_errors = validate_types_and_rules(rows)\n    return ValidationResult(rows=len(rows), errors=header_errors + data_errors)",
        "detail": "labs.lab5.src.csv_validation",
        "documentation": {}
    },
    {
        "label": "REQUIRED_COLUMNS",
        "kind": 5,
        "importPath": "labs.lab5.src.csv_validation",
        "description": "labs.lab5.src.csv_validation",
        "peekOfCode": "REQUIRED_COLUMNS = [\"id\", \"name\", \"age\", \"score\"]\n@dataclass\nclass ValidationResult:\n    rows: int\n    errors: List[str]\ndef read_csv_rows(path: Path) -> List[Dict[str, str]]:\n    \"\"\"\n    Lee un CSV con encabezado y devuelve lista de dicts (valores en str).\n    \"\"\"\n    with path.open(\"r\", newline=\"\", encoding=\"utf-8\") as f:",
        "detail": "labs.lab5.src.csv_validation",
        "documentation": {}
    },
    {
        "label": "ensure_sample_csv",
        "kind": 2,
        "importPath": "labs.lab5.src.main",
        "description": "labs.lab5.src.main",
        "peekOfCode": "def ensure_sample_csv() -> None:\n    DATA_DIR.mkdir(parents=True, exist_ok=True)\n    if DATA_FILE.exists():\n        return\n    rows = [\n        {\"id\": \"1\", \"name\": \"Ana\",   \"age\": \"21\", \"score\": \"9.5\"},\n        {\"id\": \"2\", \"name\": \"Luis\",  \"age\": \"19\", \"score\": \"7.0\"},\n        {\"id\": \"3\", \"name\": \"Marta\", \"age\": \"22\", \"score\": \"10.0\"},\n    ]\n    with DATA_FILE.open(\"w\", newline=\"\", encoding=\"utf-8\") as f:",
        "detail": "labs.lab5.src.main",
        "documentation": {}
    },
    {
        "label": "demo_textutils",
        "kind": 2,
        "importPath": "labs.lab5.src.main",
        "description": "labs.lab5.src.main",
        "peekOfCode": "def demo_textutils() -> None:\n    print(\"=== Parte A — textutils ===\")\n    s = \"  Hola   mundo   de  pruebas  \"\n    print(\"normalize_spaces:\", normalize_spaces(s))\n    print(\"word_count:\", word_count(s))\n    print(\"is_palindrome('Anita lava la tina'):\", is_palindrome(\"Anita lava la tina\"))\ndef demo_csv_validation() -> None:\n    print(\"\\n=== Parte B — CSV validation ===\")\n    result = validate_csv(DATA_FILE)\n    print(\"Filas leídas:\", result.rows)",
        "detail": "labs.lab5.src.main",
        "documentation": {}
    },
    {
        "label": "demo_csv_validation",
        "kind": 2,
        "importPath": "labs.lab5.src.main",
        "description": "labs.lab5.src.main",
        "peekOfCode": "def demo_csv_validation() -> None:\n    print(\"\\n=== Parte B — CSV validation ===\")\n    result = validate_csv(DATA_FILE)\n    print(\"Filas leídas:\", result.rows)\n    if result.errors:\n        print(\"[ERRORES]\")\n        for e in result.errors:\n            print(\"-\", e)\n    else:\n        print(\"Validación OK (sin errores).\")",
        "detail": "labs.lab5.src.main",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "labs.lab5.src.main",
        "description": "labs.lab5.src.main",
        "peekOfCode": "def main() -> None:\n    ensure_sample_csv()\n    demo_textutils()\n    demo_csv_validation()\n    print(\"\\n✅ Lab 5 ejecutado correctamente desde main.py\")\nif __name__ == \"__main__\":\n    main()",
        "detail": "labs.lab5.src.main",
        "documentation": {}
    },
    {
        "label": "DATA_DIR",
        "kind": 5,
        "importPath": "labs.lab5.src.main",
        "description": "labs.lab5.src.main",
        "peekOfCode": "DATA_DIR = Path(__file__).resolve().parents[1] / \"data\"\nDATA_FILE = DATA_DIR / \"sample.csv\"\ndef ensure_sample_csv() -> None:\n    DATA_DIR.mkdir(parents=True, exist_ok=True)\n    if DATA_FILE.exists():\n        return\n    rows = [\n        {\"id\": \"1\", \"name\": \"Ana\",   \"age\": \"21\", \"score\": \"9.5\"},\n        {\"id\": \"2\", \"name\": \"Luis\",  \"age\": \"19\", \"score\": \"7.0\"},\n        {\"id\": \"3\", \"name\": \"Marta\", \"age\": \"22\", \"score\": \"10.0\"},",
        "detail": "labs.lab5.src.main",
        "documentation": {}
    },
    {
        "label": "DATA_FILE",
        "kind": 5,
        "importPath": "labs.lab5.src.main",
        "description": "labs.lab5.src.main",
        "peekOfCode": "DATA_FILE = DATA_DIR / \"sample.csv\"\ndef ensure_sample_csv() -> None:\n    DATA_DIR.mkdir(parents=True, exist_ok=True)\n    if DATA_FILE.exists():\n        return\n    rows = [\n        {\"id\": \"1\", \"name\": \"Ana\",   \"age\": \"21\", \"score\": \"9.5\"},\n        {\"id\": \"2\", \"name\": \"Luis\",  \"age\": \"19\", \"score\": \"7.0\"},\n        {\"id\": \"3\", \"name\": \"Marta\", \"age\": \"22\", \"score\": \"10.0\"},\n    ]",
        "detail": "labs.lab5.src.main",
        "documentation": {}
    },
    {
        "label": "normalize_spaces",
        "kind": 2,
        "importPath": "labs.lab5.src.textutils",
        "description": "labs.lab5.src.textutils",
        "peekOfCode": "def normalize_spaces(s: str) -> str:\n    \"\"\"\n    Colapsa espacios múltiples, quita espacios al inicio/fin.\n    \"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"normalize_spaces() espera str\")\n    return \" \".join(s.split())\ndef word_count(s: str) -> int:\n    \"\"\"\n    Cuenta palabras separadas por espacio tras normalizar.",
        "detail": "labs.lab5.src.textutils",
        "documentation": {}
    },
    {
        "label": "word_count",
        "kind": 2,
        "importPath": "labs.lab5.src.textutils",
        "description": "labs.lab5.src.textutils",
        "peekOfCode": "def word_count(s: str) -> int:\n    \"\"\"\n    Cuenta palabras separadas por espacio tras normalizar.\n    \"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"word_count() espera str\")\n    s = normalize_spaces(s)\n    if s == \"\":\n        return 0\n    return len(s.split(\" \"))",
        "detail": "labs.lab5.src.textutils",
        "documentation": {}
    },
    {
        "label": "is_palindrome",
        "kind": 2,
        "importPath": "labs.lab5.src.textutils",
        "description": "labs.lab5.src.textutils",
        "peekOfCode": "def is_palindrome(s: str, ignore_case: bool = True, ignore_spaces: bool = True) -> bool:\n    \"\"\"\n    Determina si s es palíndromo.\n    - ignore_case: ignora mayúsculas/minúsculas\n    - ignore_spaces: ignora espacios\n    \"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"is_palindrome() espera str\")\n    t = s\n    if ignore_spaces:",
        "detail": "labs.lab5.src.textutils",
        "documentation": {}
    },
    {
        "label": "test_valid_dataset",
        "kind": 2,
        "importPath": "labs.lab5.tests.test_csv_validation",
        "description": "labs.lab5.tests.test_csv_validation",
        "peekOfCode": "def test_valid_dataset(tmp_path: pathlib.Path):\n    p = tmp_path / \"ok.csv\"\n    rows = [\n        {\"id\": \"1\", \"name\": \"Ana\", \"age\": \"20\", \"score\": \"10.5\"},\n        {\"id\": \"2\", \"name\": \"Luis\", \"age\": \"0\",  \"score\": \"0\"},\n    ]\n    _write_csv(p, rows)\n    result = validate_csv(p)\n    assert result.rows == 2\n    assert result.errors == []",
        "detail": "labs.lab5.tests.test_csv_validation",
        "documentation": {}
    },
    {
        "label": "test_invalid_dataset",
        "kind": 2,
        "importPath": "labs.lab5.tests.test_csv_validation",
        "description": "labs.lab5.tests.test_csv_validation",
        "peekOfCode": "def test_invalid_dataset(tmp_path: pathlib.Path):\n    p = tmp_path / \"bad.csv\"\n    rows = [\n        {\"id\": \"1\", \"name\": \"Ana\",  \"age\": \"-1\", \"score\": \"1.0\"},   # age negativo\n        {\"id\": \"1\", \"name\": \"   \",  \"age\": \"x\",  \"score\": \"-2.0\"},  # id duplicado, name vacío, age inválido, score negativo\n        {\"id\": \"y\", \"name\": \"M\",    \"age\": \"3\",  \"score\": \"z\"},     # id inválido, score inválido\n    ]\n    _write_csv(p, rows)\n    result = validate_csv(p)\n    assert result.rows == 3",
        "detail": "labs.lab5.tests.test_csv_validation",
        "documentation": {}
    },
    {
        "label": "test_normalize_spaces_basic",
        "kind": 2,
        "importPath": "labs.lab5.tests.test_textutils",
        "description": "labs.lab5.tests.test_textutils",
        "peekOfCode": "def test_normalize_spaces_basic():\n    assert normalize_spaces(\"  hola   mundo  \") == \"hola mundo\"\ndef test_word_count():\n    assert word_count(\"  hola   mundo  \") == 2\n    assert word_count(\"\") == 0\ndef test_is_palindrome_defaults():\n    assert is_palindrome(\"Anita lava la tina\")  # True con ignores por defecto\n    assert not is_palindrome(\"hola\")\ndef test_type_errors():\n    with pytest.raises(TypeError):",
        "detail": "labs.lab5.tests.test_textutils",
        "documentation": {}
    },
    {
        "label": "test_word_count",
        "kind": 2,
        "importPath": "labs.lab5.tests.test_textutils",
        "description": "labs.lab5.tests.test_textutils",
        "peekOfCode": "def test_word_count():\n    assert word_count(\"  hola   mundo  \") == 2\n    assert word_count(\"\") == 0\ndef test_is_palindrome_defaults():\n    assert is_palindrome(\"Anita lava la tina\")  # True con ignores por defecto\n    assert not is_palindrome(\"hola\")\ndef test_type_errors():\n    with pytest.raises(TypeError):\n        normalize_spaces(123)  # type: ignore[arg-type]\n    with pytest.raises(TypeError):",
        "detail": "labs.lab5.tests.test_textutils",
        "documentation": {}
    },
    {
        "label": "test_is_palindrome_defaults",
        "kind": 2,
        "importPath": "labs.lab5.tests.test_textutils",
        "description": "labs.lab5.tests.test_textutils",
        "peekOfCode": "def test_is_palindrome_defaults():\n    assert is_palindrome(\"Anita lava la tina\")  # True con ignores por defecto\n    assert not is_palindrome(\"hola\")\ndef test_type_errors():\n    with pytest.raises(TypeError):\n        normalize_spaces(123)  # type: ignore[arg-type]\n    with pytest.raises(TypeError):\n        word_count(None)  # type: ignore[arg-type]\n    with pytest.raises(TypeError):\n        is_palindrome(3.14)  # type: ignore[arg-type]",
        "detail": "labs.lab5.tests.test_textutils",
        "documentation": {}
    },
    {
        "label": "test_type_errors",
        "kind": 2,
        "importPath": "labs.lab5.tests.test_textutils",
        "description": "labs.lab5.tests.test_textutils",
        "peekOfCode": "def test_type_errors():\n    with pytest.raises(TypeError):\n        normalize_spaces(123)  # type: ignore[arg-type]\n    with pytest.raises(TypeError):\n        word_count(None)  # type: ignore[arg-type]\n    with pytest.raises(TypeError):\n        is_palindrome(3.14)  # type: ignore[arg-type]",
        "detail": "labs.lab5.tests.test_textutils",
        "documentation": {}
    }
]